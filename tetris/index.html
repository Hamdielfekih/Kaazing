<!DOCTYPE html>
<html>
<head>

<meta charset="UTF-8">
<meta name="viewport" content="initial-scale=1, user-scalable=no">  
  
<title>Tetris</title>

<link href="welcome.css" rel="stylesheet" type="text/css">

<script src="templates.array.js" type="text/javascript"></script>
<script src="gateway.js" type="text/javascript"></script>
  
<script type="text/javascript">
var BLANK = '.';
var BLOCK_SIZE = 4;
var BOARD_HEIGHT = 20;  
var FREQUENCY_DOWN = 0.10;
var FREQUENCY_SIDE = 0.15;
var KAAZING_ID = 'd71dfe3a-818e-4f9c-8af6-fb81649d9a6d';
var TETRIS = 'tetris_topic';

var board = null;
var board_width = null;
var box_size = null;
var colors = null;
var commands = null;
var fall_frequency = null;
var falling = null;    
var last_fall_time = null;
var last_move_down = null;
var last_move_side = null;
var level = null;
var lookup = null;
var kaazing = null;
var move_down = null;
var move_left = null;
var move_right = null;
var pieces = null;
var score = null;

// Fall rate in seconds
Date.seconds = function()
{
  return Math.floor( Date.now() / 1000 );
}  
  
Number.prototype.mod = function( n ) {
    return ( ( this % n ) + n ) % n;
};

function add_to_board()
{
  console.log( 'Add to board.' );
  
  for( var x = 0; x < BLOCK_SIZE; x++ )
  {
    for( var y = 0; y < BLOCK_SIZE; y++ )
    {
      if( falling.blocks[falling.rotation][y][x] != BLANK )
      {
        lookup[y + falling.y][x + falling.x].setAttribute( 'data-fill', falling.color );          
      }
    }
  }
}

function build_board()
{
  var box = null;
  var row = null;
  
  console.log( 'Build board.' );
  
  // Box size
  box_size = Math.floor( window.innerHeight / BOARD_HEIGHT );

  // Board width in boxes
  board_width = Math.floor( window.innerWidth / box_size );
  
  // Size and position physical board
  board = document.querySelector( '.board' );
  board.style.height = ( box_size * BOARD_HEIGHT ) + 'px';
  board.style.width = ( board_width * box_size ) + 'px';
  board.style.left = Math.floor( ( window.innerWidth - board.clientWidth ) / 2 ) + 'px';

  // Blocks in board
  // Keep reference for fast lookup
  lookup = [];
  
  for( var y = 0; y < BOARD_HEIGHT; y++ )
  {
    row = [];
    
    for( var x = 0; x < board_width; x++ )
    {
      // Create element
      box = document.createElement( 'div' );
      
      // Sizing and placement
      box.style.width = box_size + 'px';
      box.style.height = box_size + 'px';
      box.style.position = 'absolute';
      box.style.left = ( x * box_size ) + 'px';
      box.style.top = ( y * box_size ) + 'px';      
      
      // Logical board
      box.setAttribute( 'data-fill', BLANK );
      
      // Add to DOM
      board.appendChild( box );
      
      // Add to logical row
      row.push( box );
    }
    
    // Add row to board
    lookup.push( row );
  }
}
  
function build_colors()
{
  console.log( 'Build colors.' );
  
  colors = [];
  
  colors.push( 'bob' );
  colors.push( 'michel' );  
  colors.push( 'mohsen' );  
  colors.push( 'peter' );  
  colors.push( 'kevin' );    
}
  
function build_pieces()
{
  console.log( 'Build pieces.' );
  
  pieces = [];
  
  pieces.push( SHAPE_I );
  pieces.push( SHAPE_J );
  pieces.push( SHAPE_L );
  pieces.push( SHAPE_O );
  pieces.push( SHAPE_S );
  pieces.push( SHAPE_T );
  pieces.push( SHAPE_Z );
}
  
// Rate of fall
// Can be tuned
function calculate_fall_frequency( level )
{
  console.log( 'Calculate fall frequency.' );
  
  return 0.27 - ( level * 0.02 );
}
  
// Level based on score
// Can be tuned
function calculate_level( score ) 
{
  console.log( 'Calculate level.' );
    
  return Math.round( score / 10 ) + 1;
}    
  
function draw_board()
{
  console.log( 'Draw board.' );
  
  for( var y = 0; y < BOARD_HEIGHT; y++ )
  {
    for( var x = 0; x < board_width; x++ )
    {
      if( lookup[y][x].getAttribute( 'data-fill' ) == BLANK ) 
      {
        lookup[y][x].className = 'none';  
      } else {
        lookup[y][x].className = lookup[y][x].getAttribute( 'data-fill' );          
      }
    }
  }
}
  
function draw_piece()
{
  console.log( 'Draw piece.' );
  
  for( var y = 0; y < BLOCK_SIZE; y++ )
  {
    for( var x = 0; x < BLOCK_SIZE; x++ )
    {
      if( falling.blocks[falling.rotation][y][x] != BLANK )
      {
        lookup[falling.y + y][falling.x + x].className = falling.color;
      }
    }
  }
}
  
function get_new_piece()
{
  var piece = null;
  var rotation = null;
  
  console.log( 'Get new piece.' );
  
  piece = Math.floor( Math.random() * pieces.length );
  rotation = Math.floor( Math.random() * pieces[piece].length );
  
  return {
    blocks: pieces[piece],
    color: colors[Math.floor( Math.random() * colors.length )],    
    rotation: rotation,
    x: Math.floor( ( board_width - BLOCK_SIZE ) / 2 ),
    y: 0
  };
}
  
function is_complete_line( y )
{
  for( var x = 0; x < board_width; x++ )
  {
    if( lookup[y][x].getAttribute( 'data-fill' ) == BLANK )
    {
      return false;  
    }
  }
  
  return true;   
}
  
function is_on_board( x, y )
{
  return x >= 0 && x < board_width && y < BOARD_HEIGHT;
}
  
function is_valid_position( adjust_x, adjust_y )
{
  var is_above_board = null;
  
  for( var x = 0; x < BLOCK_SIZE; x++ )
  {
    for( var y = 0; y < BLOCK_SIZE; y++ )
    {
      is_above_board = y + falling.y + adjust_y < 0;
      
      if( is_above_board || falling.blocks[falling.rotation][y][x] == BLANK )
      {
        continue;
      }
      
      if( !is_on_board( x + falling.x + adjust_x, y + falling.y + adjust_y ) )
      {
        return false;   
      }
         
      if( lookup[y + falling.y + adjust_y][x + falling.x + adjust_x].getAttribute( 'data-fill' ) != BLANK )
      {
        return false;      
      }
    }
  }
  
  return true;
}
  
function remove_completed_lines()
{
  var lines_removed = null;
  var pull_y = null;
  var y = null;
  
  lines_removed = 0;
  y = BOARD_HEIGHT - 1;  
  
  while( y >= 0 )
  {
    if( is_complete_line( y ) )
    {
      for( var pull_y = y; pull_y > 0; pull_y-- )
      {
        for( var x = 0; x < board_width; x++ )
        {
          lookup[pull_y][x].setAttribute( 'data-fill', lookup[pull_y - 1][x].getAttribute( 'data-fill' ) );  
        }
      }
      
      for( x = 0; x < board_width; x++ )
      {
        lookup[0][x].setAttribute( 'data-fill', BLANK );  
      }      
      
      lines_removed = lines_removed + 1;
    } else {
      y = y - 1;
    }
  }
  
  return lines_removed;
}
  
function tick()
{
  if( falling == null )
  {
    falling = get_new_piece();
    last_fall_time = Date.seconds();
    
    if( !is_valid_position( 0, 0 ) )
    {
      console.log( 'Game over.' );
      return;
    }
  }
  
  if( Date.seconds() - last_fall_time > fall_frequency )
  {
    if( !is_valid_position( 0, 1 ) )
    {
      add_to_board();
    
      score = score + remove_completed_lines();  
      level = calculate_level( score );
      fall_frequency = calculate_fall_frequency( score );
      
      falling = null;
    } else {
      falling.y = falling.y + 1;
      last_fall_time = Date.seconds();      
    }
  }
  
  draw_board();
  
  if( falling != null )
  {
    draw_piece();  
  }
  
  requestAnimationFrame( tick );
}
  
function do_connect()
{
  console.log( 'Connected.' );
  
  kaazing.subscribe( TETRIS );
  kaazing.on( Gateway.EVENT_MESSAGE, do_message );
}
  
function do_message( message )
{
  var data = null;
  
  console.log( message );
    
  data = JSON.parse( message );

  if( data.type == 'up' )
  {
    if( data.key == 'left' ) 
    {
      move_left = false;  
    } else if( data.key == 'right' ) {
      move_right = false;  
    } else if( data.key == 'down' ) {
      move_down = false;  
    }
  } else if( data.type == 'down' ) {
    if( data.key == 'left' && is_valid_position( -1, 0 ) )
    {
      falling.x = falling.x - 1;
      move_left = true;
      move_right = false;
      last_move_side = Date.seconds();
    } else if( data.key == 'right' && is_valid_position( 1, 0 ) ) {
      falling.x = falling.x + 1;
      move_right = true;
      move_left = false;
      last_move_side = Date.seconds();
    } else if( data.key == 'down' ) {
      move_down = true;
      
      if( is_valid_position( 0, 1 ) )
      {
        falling.y = falling.y + 1;
      }
      
      last_move_down = Date.seconds();
    } else if( data.key == 'clock' ) {
      falling.rotation = ( falling.rotation + 1 ).mod( 4 );
      
      if( !is_valid_position( 0, 0 ) ) 
      {
        falling.rotation = ( falling.rotation - 1 ).mod( 4 );        
      }
    } else if( data.key == 'counter' ) {
      console.log( ( falling.rotation - 1 ) % 4 );
      falling.rotation = ( falling.rotation - 1 ).mod( 4 );
      
      if( !is_valid_position( 0, 0 ) ) 
      {
        falling.rotation = ( falling.rotation + 1 ).mod( 4 );        
      }
    }
  }
  
  if( ( move_left || move_right ) && ( Date.seconds() - last_move_side ) > FREQUENCY_SIDE )
  {
    if( move_left && is_valid_position( -1, 0 ) )
    {
      falling.x = falling.x - 1;  
    } else if( move_right && is_valid_position( 1, 0 ) ) {
      falling.x = falling.x + 1;
    }
    
    last_move_side = Date.seconds();
  }  
  
  if( move_down && ( ( Date.seconds() - last_move_down ) > FREQUENCY_DOWN ) && is_valid_position( 0, 1 ) )
  {
    falling.y = falling.y + 1;
    last_move_down = Date.seconds();
  }
}
  
function do_window_load()
{
  console.log( 'Load.' );
  
  build_colors();
  build_pieces();
  build_board();  
  
  last_move_down = Date.seconds();
  last_move_side = Date.seconds();
  last_fall_time = Date.seconds();
  
  commands = [];
  
  score = 0;
  level = calculate_level( score );
  fall_frequency = calculate_fall_frequency( level );
  
  falling = get_new_piece();
  
  kaazing = Gateway.connect( KAAZING_ID );
  kaazing.on( Gateway.EVENT_CONNECT, do_connect );
  
  requestAnimationFrame( tick );
}
  
window.addEventListener( 'load', do_window_load );  
</script>  
  
</head>
<body>  
 
<!-- Board -->
<div class="board"></div>
  
</body>
</html>
